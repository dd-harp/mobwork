---
title: "How to add a new model to the library: Human Infection" 
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document: 
    theme: paper 
vignette: >
  %\VignetteIndexEntry{The Generalized Ross-Macdonald Adult Mosquito Model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Required Functions

Adding a new model to the dynamical component of class $\cal X$ -- human infection dynamics, including immunity -- follows a standard template. The `S3` class functions are defined in [human-interface.R](https://github.com/dd-harp/exDE/blob/main/R/human-interface.R){target="_blank"}, and several examples are posted in the `exDE` github repository, including the `SIS` model [human-SIS.R](https://github.com/dd-harp/exDE/blob/main/R/human-SIS.R){target="_blank"}. 


The underlying mathematics has been explained in [Spatial Dynamics of Malaria Transmission](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1010684){target="_blank"}
^[Wu SL, Henry JM, Citron DT, Mbabazi Ssebuliba D, Nakakawa Nsumba J, SÃ¡nchez C. HM, et al. (2023) Spatial dynamics of malaria transmission. PLoS Comput Biol 19(6): e1010684. https://doi.org/10.1371/journal.pcbi.1010684]

## `F_X` 

The function `F_X` returns the effective density of infectious humans for each stratum. In the `SIS` model, the returned value is $cX$ where prevalence is $X/H$. The constant $c$ is the probability a mosquito would become infected after blood feeding on an infected human. If there are multiple infectious classes, then this

## `F_pr`

The function `F_pr` computes the models *true* prevalence using the variable names. It is passed the `varslist` that is created by `parse_deout` (see below). 

## `F_b`

The function `F_b` returns the model-defined probability an infective bite by a mosquito would cause an infection. This could include the combined effects of inefficient transmission, pre-erytrocytic immunity, and perhaps some effects of blood stage immunity. In a model with no effect, the return value would be $1$.  

## `dXdt` 

The function must compute and return the derivatives. The style guidelines are to:

+ Extract the variables by name using the indices attached to `Xpar` 

+ Use `with(pars$Xpar,` to attach the parameter values by name 

+ Compute the derivatives using human readable formulas.  

+ Return the derivatives as a concatenated vector  

```{r, eval=F}
dXdt.SIS <- function(t, y, pars, FoI) {
  with(pars$Xpar, {
    X <- y[X_ix]
    H <- F_H(t, y, pars)

    dX <- FoI*(H - X) - r*X

    return(c(dX))
  })
}
```

If the model will have human demography, then each variable's derivative must be transformed by the same matrix as the human population density, `H`.  Any disease induced mortality should be included in the derivative describing changes in human population density, `dH`. 

```{r, eval=F}
dXdt.SISdH <- function(t, y, pars, FoI) {
  with(pars$Xpar, {

    H <- F_H(t, y, pars)
    X <- y[X_ix]

    dX <- FoI*(H - X) - r*X + dHdt(t, X, pars)
    dH <- Births(t, H, pars) + dHdt(t, H, pars)

    return(c(dX, dH))
  })
}
```

## `setup_X`

This function must set up `Xpar` and it must also set up the initial values. By convention, the functions that get called are not `S3` class functions.   

```{r, eval=F}
setup_X.SIS = function(pars, Xname, Xopts=list()){
  pars$Xname = "SIS"
  pars = make_Xpar_SIS(pars, Xopts)
  pars = make_Xinits_SIS(pars, Xopts)

  return(pars)
}
```

The function that makes parameters should assign

```{r, eval=F}
make_Xpar_SIS = function(pars, Xopts=list(),
                         b=0.55, r=1/180, c=0.15){
  with(Xopts,{
    Xpar = list()
    class(Xpar) <- c("SIS", "SISdX")

    Xpar$b = checkIt(b, pars$nStrata)
    Xpar$c = checkIt(c, pars$nStrata)
    Xpar$r = checkIt(r, pars$nStrata)

    pars$Xpar = Xpar
    return(pars)
})}
```


```{r}
make_Xinits_SIS = function(pars, Xopts = list(), X0=1){with(Xopts,{
  inits = list()
  inits$X0 = checkIt(X0, pars$nStrata)
  pars$Xinits = inits
  return(pars)
})}

```

#' @title Parse the output of deSolve and return variables for the SIS model
#' @description Implements [parse_deout_X] for the SIS model
#' @inheritParams parse_deout_X
#' @return none
#' @export
parse_deout_X.SIS <- function(deout, pars) {
  time = deout[,1]
  Hlist <- parse_deout_H(deout, pars)
  with(Hlist,{
    X = deout[,pars$Xpar$X_ix+1]
    return(list(time=time, X=X, H=H))
})}

#' @title Compute the HTC for the SIS model
#' @description Implements [HTC] for the SIS model with demography.
#' @inheritParams HTC
#' @return a [numeric] vector
#' @export
HTC.SIS <- function(pars) {
  with(pars$Xpar,
    return(c/r)
  )
}

#' @title Add indices for human population to parameter list
#' @description Implements [make_indices_X] for the SIS model.
#' @inheritParams make_indices_X
#' @return none
#' @importFrom utils tail
#' @export
make_indices_X.SIS <- function(pars) {
  pars$Xpar$X_ix <- seq(from = pars$max_ix+1, length.out = pars$nStrata)
  pars$max_ix <- tail(pars$Xpar$X_ix, 1)
  return(pars)
}

#' @title Make parameters for SIS human model
#' @param pars a [list]
#' @param b transmission probability (efficiency) from mosquito to human
#' @param c transmission probability (efficiency) from human to mosquito
#' @param r recovery rate
#' @return a [list]
#' @export
make_parameters_X_SIS <- function(pars, b, c, r) {
  stopifnot(is.numeric(b), is.numeric(c), is.numeric(r))
  Xpar <- list()
  class(Xpar) <- c('SIS', 'SISdX')
  Xpar$b <- b
  Xpar$c <- c
  Xpar$r <- r
  pars$Xpar <- Xpar
  return(pars)
}

#' @title Make inits for SIS human model
#' @param pars a [list]
#' @param X0 size of infected population in each strata
#' @return none
#' @export
make_inits_X_SIS <- function(pars, X0) {
  stopifnot(is.numeric(X0))
  pars$Xinits <- list(X0=X0)
  return(pars)
}

#' @title Update inits for the SIS human model from a vector of states
#' @param pars a [list]
#' @param y0 a vector of initial values
#' @return none
#' @export
update_inits_X.SIS <- function(pars, y0) {
  X0 = y0[pars$Xpar$X_ix]
  pars = make_inits_X_SIS(pars, X0)
  return(pars)
}


#' @title Return initial values as a vector
#' @description This method dispatches on the type of `pars$Xpar`.
#' @param pars a [list]
#' @return none
#' @export
get_inits_X.SIS <- function(pars){
  pars$Xinits$X0
}

#' Plot the density of infected individuals for the SIS model
#'
#' @inheritParams xde_plot_X
#' @export
xde_plot_X.SIS = function(pars, clrs="black", llty=1, stable=FALSE, add_axes=TRUE){
  vars=with(pars$outputs,if(stable==TRUE){stable_orbits}else{orbits})

  if(add_axes==TRUE)
    with(vars$XH,
         plot(time, 0*time, type = "n", ylim = c(0, max(H)),
              ylab = "# Infected", xlab = "Time"))

  xde_lines_X(vars$XH, pars, clrs, llty)
}


#' Add lines for the density of infected individuals for the SIS model
#'
#' @inheritParams xde_lines_X
#'
#' @export
xde_lines_X.SIS = function(XH, pars, clrs="black", llty=1){
  with(XH,{
    if(pars$nStrata==1) lines(time, X, col=clrs[1], lty = llty[1])
    if(pars$nStrata>1){
      if (length(clrs)==1) clrs=rep(clrs, pars$nStrata)
      if (length(llty)==1) llty=rep(llty, pars$nStrata)
      for(i in 1:pars$nStrata){
        lines(time, X[,i], col=clrs[i], lty = llty[i])
      }
    }
  })}
